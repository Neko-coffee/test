# AQR统计指标详细解释 📊

## 🎯 核心问题解答

### **Q1: 相对变化（relative_change）是什么意思？**

**相对变化**是衡量特征调制强度的最重要指标！

```python
# 定义
relative_change = mean(|调制后特征 - 原始特征| / |原始特征|)

# 直观理解
如果relative_change = 0.07 (7%)
意味着：平均每个特征元素变化了其原值的7%

# 示例
原始特征值：1.0
调制后：1.07 或 0.93
相对变化：7%

原始特征值：5.0  
调制后：5.35 或 4.65
相对变化：7%
```

**为什么重要？**
- ✅ 衡量调制对特征的**实际影响**
- ✅ 不同特征元素数值范围不同，相对变化消除了绝对值的影响
- ✅ 直接反映Transformer需要适应的难度

**您的数据**：
```python
BEV相对变化: 7%      # ✅ 非常温和，Transformer容易适应
Camera相对变化: 33.3%  # ⚠️ 偏强，需要更多训练
```

---

### **Q2: 为什么Camera的相对变化比BEV大得多？**

有三个主要原因：

#### **原因1：权重图裁剪失效** 🔥

```python
BEV权重图：
  max: 1.5  ✅ 裁剪生效
  调制公式：特征 × (0.7 × 权重图 + 0.3)
  最大调制：特征 × (0.7 × 1.5 + 0.3) = 特征 × 1.35
  相对变化：35%左右

Camera权重图：
  max: 70.8  ⚠️ 裁剪失效！
  调制公式：特征 × (0.7 × 权重图 + 0.3)
  最大调制：特征 × (0.7 × 70.8 + 0.3) = 特征 × 49.86
  相对变化：可达4986%！

但实际只有33.3%，因为：
  - 只有少数像素有极高权重
  - 大部分区域权重仍然正常
  - 平均下来是33.3%
```

**解决方案**：修复Camera权重图裁剪，将max从70.8降到1.5

---

#### **原因2：特征图尺度不同**

```python
BEV特征图：
  尺寸：128 × 128 = 16,384 像素
  Query数：1730个
  覆盖率：1730 / 16384 ≈ 10.6%
  特点：权重分布稀疏 ✅

Camera特征图：
  尺寸：6 × 20 × 50 = 6,000 像素
  Query数：1730个
  覆盖率：1730 / 6000 ≈ 28.8%
  特点：权重分布密集 ⚠️
  
结果：Camera权重图更"拥挤"，调制更强
```

---

#### **原因3：高斯散布范围**

```python
假设gaussian_sigma = 1.0

BEV（128×128）：
  每个Query影响范围：约5×5像素
  相对范围：5×5 / (128×128) = 0.15%
  权重叠加：较少

Camera（6×20×50）：
  每个Query影响范围：约5×5像素
  相对范围：5×5 / (6×20×50) = 0.42%
  权重叠加：较多
  
结果：Camera上权重叠加更严重，局部值更高
```

---

### **Q3: 权重统计中的mean和std具体是什么意思？**

#### **mean（均值）- 整体趋势**

```python
lidar_weights mean: 0.7019 (70.2%)

含义：
  - 所有Query的LiDAR权重平均值
  - 反映整体上对LiDAR模态的依赖程度
  
计算示例：
  Query 1: 0.85
  Query 2: 0.65
  Query 3: 0.72
  ...
  Query 1730: 0.68
  
  mean = (0.85 + 0.65 + 0.72 + ... + 0.68) / 1730 = 0.7019

解读：
  - mean ≈ 0.5: 模态权重中性
  - mean ≈ 0.7: 较依赖该模态（您的情况）✅
  - mean ≈ 1.0: 过度依赖该模态 ⚠️
  - mean ≈ 0.0: 几乎不使用该模态 ❌
```

---

#### **std（标准差）- 区分度**

```python
lidar_weights std: 0.1570 (15.7%)

含义：
  - 衡量不同Query权重的离散程度
  - 反映AQR的**区分能力**
  
计算公式：
  std = sqrt(sum((每个权重 - mean)²) / Query总数)

根据正态分布：
  68%的权重在 [mean-std, mean+std] 范围内
  即：[0.70-0.16, 0.70+0.16] = [0.54, 0.86]

解读：
  - std很小（如0.01）：
    ❌ 所有Query权重几乎相同
    ❌ AQR没有学会区分
    ❌ 相当于没有AQR
    
  - std适中（如0.15-0.17）：
    ✅ 不同Query有不同权重（您的情况）
    ✅ AQR学会了区分不同检测任务
    ✅ 自适应能力强
    
  - std很大（如0.3）：
    ⚠️ 权重分布极端分化
    ⚠️ 可能过拟合或不稳定
```

**实际意义**：

```python
# 您的数据
LiDAR: mean=0.70, std=0.16
Camera: mean=0.72, std=0.17

说明：
1. ✅ 两种模态都被充分利用（mean都在70%）
2. ✅ 权重有良好区分度（std=15-17%）
3. ✅ 没有极端偏向某一模态
4. ✅ AQR学会了自适应调整

具体表现：
- 检测汽车（大型）：LiDAR权重高（如0.95）
- 检测行人（小型）：Camera权重高（如0.92）
- 检测路障（细长）：LiDAR权重中等（如0.65）
```

---

### **Q4: std_change和relative_change是什么？如何计算？**

这两个都是**特征调制效果**的指标，代码在`cmt_head.py`第1194-1202行：

```python
def _compute_modulation_effect(self, original, modulated):
    """计算调制效果"""
    # 计算差异
    diff = modulated - original  # 调制后 - 原始
    
    return {
        'mean_change': diff.mean().item(),           # 平均变化
        'std_change': diff.std().item(),             # 变化的标准差
        'max_change': diff.abs().max().item(),       # 最大绝对变化
        'relative_change': (diff.abs() / (original.abs() + 1e-8)).mean().item()  # 相对变化
    }
```

---

#### **std_change（变化的标准差）**

```python
实际值BEV: 0.0615

含义：
  - 特征变化量的离散程度
  - 反映调制的**均匀性**
  
计算：
  Step 1: 计算每个位置的变化量
    diff[i] = modulated[i] - original[i]
    
  Step 2: 计算变化量的标准差
    std_change = std(diff)

解读：
  - std_change小（如0.01）：
    所有位置变化程度相似（均匀调制）
    
  - std_change适中（如0.06）：
    不同位置变化程度不同（您的情况）✅
    权重高的地方变化大，权重低的地方变化小
    
  - std_change大（如0.5）：
    变化极端不均匀 ⚠️

示例：
  位置1：原始1.0，调制后1.05，变化+0.05
  位置2：原始2.0，调制后2.20，变化+0.20
  位置3：原始0.5，调制后0.53，变化+0.03
  ...
  
  std_change = std([0.05, 0.20, 0.03, ...]) = 0.0615
```

---

#### **relative_change（相对变化）🔥 最重要**

```python
实际值BEV: 0.0700 = 7%
实际值Camera: 0.3331 = 33.3%

含义：
  - 特征变化相对于原始值的比例
  - 反映调制的**实际强度**
  
计算（逐元素）：
  Step 1: 计算每个位置的相对变化
    relative_change[i] = |modulated[i] - original[i]| / |original[i]|
    
  Step 2: 取平均
    relative_change = mean(relative_change[i])

示例：
  位置1：原始1.0，调制后1.07
    相对变化：|1.07-1.0|/1.0 = 0.07 = 7%
    
  位置2：原始5.0，调制后5.35
    相对变化：|5.35-5.0|/5.0 = 0.07 = 7%
    
  位置3：原始0.1，调制后0.107
    相对变化：|0.107-0.1|/0.1 = 0.07 = 7%
  
  平均：(7% + 7% + 7%) / 3 = 7%

关键：
  - 消除了特征绝对值大小的影响
  - 真实反映调制强度
  - 直接对应Transformer需要适应的难度
```

---

## 📊 您的数据综合解读

### **权重统计**

```python
LiDAR权重：
  mean: 0.7019  → 平均70%，充分利用 ✅
  std: 0.1570   → 有区分度（68%在[0.54,0.86]） ✅
  min: 0.0938   → 某些Query只用9%LiDAR（主要用Camera） ✅
  max: 0.9824   → 某些Query用98%LiDAR（几乎全依赖） ✅
  
Camera权重：
  mean: 0.7233  → 平均72%，充分利用 ✅
  std: 0.1673   → 有区分度（68%在[0.56,0.89]） ✅
  min: 0.1408   → 最少用14%Camera ✅
  max: 0.9938   → 某些Query几乎全用Camera ✅

结论：
  ✅ 两种模态都被有效利用
  ✅ AQR学会了针对不同Query区分权重
  ✅ 权重分布健康，无极端现象
```

---

### **调制效果**

```python
BEV调制：
  relative_change: 7%  
    → 平均每个特征元素变化7%
    → 非常温和，Transformer容易适应 ✅
    
Camera调制：
  relative_change: 33.3%
    → 平均每个特征元素变化33.3%
    → 相对较强，需要更多训练适应 ⚠️
    → 原因：权重图裁剪失效（max=70.8）

结论：
  ✅ BEV调制温和有效
  ⚠️ Camera调制偏强（但residual=0.7保护了70%特征）
  🔧 修复Camera权重裁剪后，预期降到10-15%
```

---

## 🎯 关键要点总结

1. **Query数量（shape）**
   - 配置中设置：num_query=900
   - 实际训练时：1730个Query（900原始 + 830个DN）
   - DN（去噪）训练动态添加Query
   - 推理时只使用原始900个Query

2. **相对变化（relative_change）**
   - 最重要的调制强度指标
   - 衡量特征实际变化程度
   - BEV的7%非常理想
   - Camera的33.3%偏高，但可接受

3. **权重mean和std**
   - mean=70%：两种模态都被充分利用
   - std=15-17%：AQR有良好的区分能力
   - min/max范围大：自适应能力强

4. **为什么Camera相对变化大**
   - 权重图裁剪失效（主要原因）
   - 特征图尺度较小（次要原因）
   - 权重分布密集（次要原因）

5. **整体评价**
   - ✅ AQR机制工作正常
   - ✅ 初期性能下降是特征适应期的正常现象
   - ✅ 5-10 epochs后预期恢复并超越
   - 🔧 修复Camera权重裁剪可进一步提升

---

**生成时间**: 2025-10-12
**作者**: AI Assistant 🐾

